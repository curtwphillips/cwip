import { createRequire as createImportMetaRequire } from "module"; import.meta.require ||= (id) => createImportMetaRequire(import.meta.url)(id);
var z=(q,B)=>B.filter((G)=>!q.includes(G)),u=(q,B,G)=>B.map((H)=>G?!!q.find((O)=>O[G]===H):q.indexOf(H)!==-1),k=(q,B,G)=>q.reduceRight((H,O,R)=>G?B.indexOf(O[G])!==-1?H.toSpliced(R,1):H:B.indexOf(O)!==-1?H.toSpliced(R,1):H,[...q]),j=(q)=>[...new Set(q)],b=(...q)=>[...Array(Math.min(...q.map((B)=>B.length)))].map((B,G)=>q.map((H)=>H[G]));var L=(q)=>typeof q!=="undefined"&&q!==null,M=(q)=>q!==!1&&L(q),g=(q,B,G=!1)=>!G?q.indexOf(B)>-1:q.toUpperCase().indexOf(B.toUpperCase())>-1,D=(q)=>q===null||!(typeof q==="object"||typeof q==="function"),m=(q)=>typeof q==="function",o=(q)=>Number.isFinite(q),n=(q)=>typeof q==="string",w=(q)=>typeof q==="object"&&q!==null&&!Array.isArray(q),F=(q)=>D(q)?!L(q):Array.isArray(q)?q.every((B)=>F(B)):Object.keys(q).every((B)=>Array.isArray(q[B])?q[B].every((G)=>F(G)):w(q[B])?F(q[B]):!L(q[B])),c=(q,B,G=!1)=>{if(G)B=B.toLowerCase();for(let H=0;H<q.length;H++)if(B.includes(G?q[H].toLowerCase():q[H]))return!0;return!1};var v=(q,B,G)=>M(q)?B(G):G,N=(q)=>(...B)=>B.length>=q.length?q(...B):(...G)=>p(q)(...B,...G),p=(q)=>N(q);var s=function(q){let B="",G="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";for(let H=0;H<q;H++)B+=G.charAt(Math.floor(Math.random()*G.length));return B},e=async(q)=>new Promise((B)=>setTimeout(B,q));var B1=(q)=>Object.assign({},q),G1=(q)=>structuredClone(q),H1=(...q)=>Object.assign({},...q),J1=(q,B)=>z(Object.keys(B),q),K=(q,B=2)=>{const G=[];return JSON.stringify(q,function(H,O){if(typeof O==="object"&&O!==null){if(G.indexOf(O)!==-1)return;G.push(O)}return O},B)},O1=(q,B)=>{for(let G=0;G<q.length;G++)if(L(B[q[G]]))return q[G]},Q1=(q,B)=>{for(let G=0;G<q.length;G++)if(L(B[q[G]]))return B[q[G]]},S=(q,B)=>Object.prototype.hasOwnProperty.call(B,q),R1=(q,B)=>{for(let G=0;G<q.length;G++)if(!S(q[G],B))return!1;return!0},U1=(q,B)=>q.filter((G)=>!S(G,B)),W1=(q,B)=>{for(let G=0;G<q.length;G++)delete B[q[G]];return B};var d=(q)=>q[0].getFileName(),f=(q)=>q[0].getLineNumber(),Z1=(q={hideFile:!1,hideTime:!1,useLocalTime:!0})=>(...B)=>{const G=Error.prepareStackTrace;Error.prepareStackTrace=function(J,U){return U};const H=new Error;Error.captureStackTrace(H);const O=H.stack;Error.prepareStackTrace=G;let R="";const Q=q.hideFile?"":d(O).slice(process.cwd().length);if(Q)B.unshift(Q+":"+f(O));if(!q.hideTime)if(q.useLocalTime){const J=(new Date()).getTimezoneOffset()*60000,U=new Date(Date.now()-J).toISOString().slice(0,-1);B.unshift(U)}else B.unshift((new Date()).toISOString());B.forEach((J)=>{const U=typeof J==="object"?JSON.parse(K(J)):J;R+=typeof U==="string"?U:K(U),R+=" "}),console.log(R&&R.trim())};var $1=(q,B)=>+B.toFixed(q),L1=(q,B)=>Number(Math.round(Number(B+"e"+q))+"e-"+q),P1=(q,B)=>Number(Math.ceil(Number(B+"e"+q))+"e-"+q),T1=(q,B)=>Number(Math.floor(Number(B+"e"+q))+"e-"+q),F1=(q,B)=>{const G=q<0&&B>0||B<0&&q>0?-1:1,H=T(q),O=T(B),R=Math.max(H,O),Q=q.toFixed(R).split(""),J=B.toFixed(R).split("");if(Q[0]==="-")Q.shift();if(J[0]==="-")J.shift();if(Q.includes("."))Q.splice(Q.indexOf("."),1);if(J.includes("."))J.splice(J.indexOf("."),1);const U=[];let X=0;for(let Z=J.length-1;Z>-1;Z--){const $=[];U.push($);const C=Number(J[Z]);if(Z!==J.length-1)for(let _=J.length-1;_>Z;_--)$.push("0");for(let _=Q.length-1;_>-1;_--){const h=Number(Q[_]),P=(C*Number(h)+X).toFixed(0);if($.unshift(P.slice(P.length-1)),P.length>1){if(X=Number(P.slice(0,P.length-1)),_===0)$.unshift(X),X=0}else X=0}}const W=U.reduce((Z,$)=>{return A(Z,Number($.join("")))},0).toFixed(0).split(""),E=R*2,x=[...W.slice(0,W.length-E),".",...W.slice(W.length-E)];return G*Number(x.join(""))},V=(q,B,G)=>{if(B.toString().includes("e-"))B=I(B);if(G.toString().includes("e-"))G=I(G);const H=T(B),O=T(G),R=Math.max(H,O),Q=Number(B+"e"+R),J=Number(G+"e"+R);let U;if(q==="subtract")U=Q-J;else if(q==="add")U=Q+J;else if(q==="divide")return Q/J;else return;return Number(U+"e-"+R)},A=(q,B)=>V("add",q,B),K1=(q,B)=>V("subtract",q,B),V1=(q,B)=>V("divide",q,B),T=(q)=>{if(q%1===0)return 0;return q.toString().split(".")[1].length},I=(q)=>{const B=q.toString().toLowerCase(),G=B.indexOf(".");let H=B.indexOf("e");if(H===-1)return q;let O=1,R=!0;if(B.indexOf("e+")!==-1)O=2,R=!0;else O=2,R=!1;let Q,J;if(G!==-1)Q=B.slice(0,G),J=B.slice(G+1,H);else Q=B.slice(0,H),J="";const U=Number(B.slice(H+O,B.length));let X,Y,W;if(!R){X=U-Q.length,Y=".";for(W=0;W<X;W++)Y+="0";Y+=Q+J}else{X=U-J.length,Y=Q+J;for(W=0;W<X;W++)Y+="0"}return Y};export{b as zip,k as without,M as truthy,K1 as subtract,K as stringify,c as stringIncludesAny,e as sleep,B1 as shallowClone,$1 as setPrecision,P1 as roundUp,T1 as roundDown,L1 as round,j as removePrimitiveDups,W1 as removeKeys,s as randomAlpahNumeric,F1 as multiply,Z1 as log,n as isString,D as isPrimitive,w as isObject,o as isNumber,m as isFunction,F as isEmpty,u as includes,v as ifIt,S as hasKey,R1 as hasAllKeys,U1 as getMissingKeys,f as getLineFromStack,d as getFileFromStack,Q1 as firstExistingKeyValue,O1 as firstExistingKey,H1 as extend,L as existy,J1 as excludesKeys,z as excludes,V as doMath,V1 as divide,G1 as deepClone,p as curry,T as countDecimals,I as convertScientificToDecimal,g as containsString,A as add};
