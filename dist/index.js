import { createRequire as createImportMetaRequire } from "module"; import.meta.require ||= (id) => createImportMetaRequire(import.meta.url)(id);
var z=(q,B)=>B.filter((G)=>!q.includes(G)),j=(q,B,G)=>B.map((H)=>G?!!q.find((Q)=>Q[G]===H):q.indexOf(H)!==-1),k=(q,B,G)=>q.reduceRight((H,Q,U)=>G?B.indexOf(Q[G])!==-1?H.toSpliced(U,1):H:B.indexOf(Q)!==-1?H.toSpliced(U,1):H,[...q]),b=(q)=>[...new Set(q)],y=(...q)=>[...Array(Math.min(...q.map((B)=>B.length)))].map((B,G)=>q.map((H)=>H[G]));var P=(q)=>typeof q!=="undefined"&&q!==null,M=(q)=>q!==!1&&P(q),m=(q,B,G=!1)=>!G?q.indexOf(B)>-1:q.toUpperCase().indexOf(B.toUpperCase())>-1,h=(q)=>q===null||!(typeof q==="object"||typeof q==="function"),o=(q)=>typeof q==="function",n=(q)=>Number.isFinite(q),I=(q)=>typeof q==="string",w=(q)=>typeof q==="object"&&q!==null&&!Array.isArray(q),O=(q)=>h(q)?!P(q):Array.isArray(q)?q.every((B)=>O(B)):Object.keys(q).every((B)=>Array.isArray(q[B])?q[B].every((G)=>O(G)):w(q[B])?O(q[B]):!P(q[B])),c=(q,B,G=!1)=>{if(G)B=B.toLowerCase();for(let H=0;H<q.length;H++)if(B.includes(G?q[H].toLowerCase():q[H]))return!0;return!1};var v=(q,B,G)=>M(q)?B(G):G,p=(q)=>(...B)=>B.length>=q.length?q(...B):(...G)=>d(q)(...B,...G),d=(q)=>p(q);var e=function(q){let B="",G="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";for(let H=0;H<q;H++)B+=G.charAt(Math.floor(Math.random()*G.length));return B},s=async(q)=>new Promise((B)=>setTimeout(B,q));var B0=(q)=>Object.assign({},q),G0=(q)=>structuredClone(q),H0=(...q)=>Object.assign({},...q),J0=(q,B)=>z(Object.keys(B),q),T=(q,B=2)=>{const G=[];return JSON.stringify(q,function(H,Q){if(typeof Q==="object"&&Q!==null){if(G.indexOf(Q)!==-1)return;G.push(Q)}return Q},B)},Q0=(q,B)=>{for(let G=0;G<q.length;G++)if(P(B[q[G]]))return q[G]},R0=(q,B)=>{for(let G=0;G<q.length;G++)if(P(B[q[G]]))return B[q[G]]},S=(q,B)=>Object.prototype.hasOwnProperty.call(B,q),U0=(q,B)=>{for(let G=0;G<q.length;G++)if(!S(q[G],B))return!1;return!0},W0=(q,B)=>q.filter((G)=>!S(G,B)),X0=(q,B)=>{for(let G=0;G<q.length;G++)delete B[q[G]];return B};var f=(q)=>q[0].getFileName(),A=(q)=>q[0].getLineNumber(),_0=(q={hideFile:!1,hideTime:!1,useLocalTime:!0})=>(...B)=>{const G=Error.prepareStackTrace;Error.prepareStackTrace=function(J,W){return W};const H=new Error;Error.captureStackTrace(H);const Q=H.stack;Error.prepareStackTrace=G;let U="";const R=q.hideFile?"":f(Q).slice(process.cwd().length);if(R)B.unshift(R+":"+A(Q));if(!q.hideTime)if(q.useLocalTime){const J=(new Date()).getTimezoneOffset()*60000,W=new Date(Date.now()-J).toISOString().slice(0,-1);B.unshift(W)}else B.unshift((new Date()).toISOString());B.forEach((J)=>{const W=typeof J==="object"?JSON.parse(T(J)):J;U+=typeof W==="string"?W:T(W),U+=" "}),console.log(U&&U.trim())};var P0=(q,B)=>+B.toFixed(q),F0=(q,B)=>Number(Math.round(Number(B+"e"+q))+"e-"+q),K0=(q,B)=>Number(Math.ceil(Number(B+"e"+q))+"e-"+q),O0=(q,B)=>Number(Math.floor(Number(B+"e"+q))+"e-"+q),T0=(q,B)=>{const G=q<0&&B>0||B<0&&q>0?-1:1,H=K(q),Q=K(B),U=Math.max(H,Q),R=q.toFixed(U).split(""),J=B.toFixed(U).split("");if(R[0]==="-")R.shift();if(J[0]==="-")J.shift();if(R.includes("."))R.splice(R.indexOf("."),1);if(J.includes("."))J.splice(J.indexOf("."),1);const W=[];let Y=0;for(let _=J.length-1;_>-1;_--){const L=[];W.push(L);const x=Number(J[_]);if(_!==J.length-1)for(let $=J.length-1;$>_;$--)L.push("0");for(let $=R.length-1;$>-1;$--){const N=Number(R[$]),F=(x*Number(N)+Y).toFixed(0);if(L.unshift(F.slice(F.length-1)),F.length>1){if(Y=Number(F.slice(0,F.length-1)),$===0)L.unshift(Y),Y=0}else Y=0}}const X=W.reduce((_,L)=>{return u(_,Number(L.join("")))},0).toFixed(0).split(""),E=U*2,D=[...X.slice(0,X.length-E),".",...X.slice(X.length-E)];return G*Number(D.join(""))},V=(q,B,G)=>{if(B.toString().includes("e-"))B=C(B);if(G.toString().includes("e-"))G=C(G);const H=K(B),Q=K(G),U=Math.max(H,Q),R=Number(B+"e"+U),J=Number(G+"e"+U);let W;if(q==="subtract")W=R-J;else if(q==="add")W=R+J;else if(q==="divide")return R/J;else return;return Number(W+"e-"+U)},u=(q,B)=>V("add",q,B),V0=(q,B)=>V("subtract",q,B),E0=(q,B)=>V("divide",q,B),K=(q)=>{if(!I(q)&&Number(q)%1===0)return 0;return q.toString().split(".")[1].length},C=(q)=>{const B=q.toString().toLowerCase(),G=B.indexOf(".");let H=B.indexOf("e");if(H===-1)return q;let Q=1,U=!0;if(B.indexOf("e+")!==-1)Q=2,U=!0;else Q=2,U=!1;let R,J;if(G!==-1)R=B.slice(0,G),J=B.slice(G+1,H);else R=B.slice(0,H),J="";const W=Number(B.slice(H+Q,B.length));let Y,Z,X;if(!U){Y=W-R.length,Z=".";for(X=0;X<Y;X++)Z+="0";Z+=R+J}else{Y=W-J.length,Z=R+J;for(X=0;X<Y;X++)Z+="0"}return Z};export{y as zip,k as without,M as truthy,V0 as subtract,T as stringify,c as stringIncludesAny,s as sleep,B0 as shallowClone,P0 as setPrecision,K0 as roundUp,O0 as roundDown,F0 as round,b as removePrimitiveDups,X0 as removeKeys,e as randomAlpahNumeric,T0 as multiply,_0 as log,I as isString,h as isPrimitive,w as isObject,n as isNumber,o as isFunction,O as isEmpty,j as includes,v as ifIt,S as hasKey,U0 as hasAllKeys,W0 as getMissingKeys,A as getLineFromStack,f as getFileFromStack,R0 as firstExistingKeyValue,Q0 as firstExistingKey,H0 as extend,P as existy,J0 as excludesKeys,z as excludes,V as doMath,E0 as divide,G0 as deepClone,d as curry,K as countDecimals,C as convertScientificToDecimal,m as containsString,u as add};
